Customer.java:

package com.crm.wm.entities;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.ToString;

import java.util.List;


@AllArgsConstructor
@NoArgsConstructor
@ToString
@Entity
@Table(name = "Customers")
@Data
public class Customer {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long customerID;

    private String firstName;
    private String lastName;
    private String email;
    private String phoneNumber;
    private String address;

    @ManyToOne
    @JoinColumn(name = "MunicipalityID")
    private Municipality municipality;

    @Enumerated(EnumType.STRING)
    private CustomerType customerType;

    @OneToOne(mappedBy = "customer", cascade = CascadeType.ALL)
    private Company company;

    @ManyToMany
    @JoinTable(
            name = "Customer_Product",
            joinColumns = @JoinColumn(name = "CustomerID"),
            inverseJoinColumns = @JoinColumn(name = "ProductID")
    )
    private List<Product> products;

    // Other fields, constructors, getters, setters

    public void setCompany(Company company) {
        if (company == null) {
            if (this.company != null) {
                this.company.setCustomer(null);
            }
        }
        else {
            company.setCustomer(this);
        }
        this.company = company;
    }
}



Company.java:

package com.crm.wm.entities;

import com.fasterxml.jackson.annotation.JsonIgnore;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.ToString;

@AllArgsConstructor
@NoArgsConstructor
@ToString
@Entity
@Table(name = "Companies")
@Data
public class Company {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long companyID;

    private String companyName;

    @OneToOne
    @JoinColumn(name = "customerID")
    @JsonIgnore
    private Customer customer;


    // Other fields, constructors, getters, setters

}



CustomerProduct.java:

package com.crm.wm.entities;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.ToString;

@AllArgsConstructor
@NoArgsConstructor
@ToString
@Entity
@Table(name = "Customer_Product")
@Data
public class CustomerProduct {

    @Id
    @ManyToOne
    @JoinColumn(name = "CustomerID")
    private Customer customer;

    @Id
    @ManyToOne
    @JoinColumn(name = "ProductID")
    private Product product;

    // Other fields, constructors, getters, setters
}



CustomerType.java:

package com.crm.wm.entities;

public enum CustomerType {
    COMPANY,
    INDIVIDUAL
}



Employee.java:

package com.crm.wm.entities;

import java.util.HashSet;
import java.util.Set;
import jakarta.persistence.*;
import jakarta.validation.constraints.*;

@Entity
@Table(name = "employees",
    uniqueConstraints = {
      @UniqueConstraint(columnNames = "username"),
      @UniqueConstraint(columnNames = "email")
    })
public class Employee {
  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Long employeeID;

  private String firstName;
  private String lastName;

  @NotBlank
  @Size(max = 20)
  private String username;

  @NotBlank
  @Size(max = 50)
  @Email
  private String email;

  @NotBlank
  @Size(max = 120)
  private String password;

  @ManyToMany(fetch = FetchType.LAZY)
  @JoinTable(  name = "user_roles",
        joinColumns = @JoinColumn(name = "user_id"),
        inverseJoinColumns = @JoinColumn(name = "role_id"))
  private Set<Role> roles = new HashSet<>();

  public Employee() {
  }

  public Employee(String username, String email, String password) {
    this.username = username;
    this.email = email;
    this.password = password;
  }

  public Long getId() {
    return employeeID;
  }

  public void setId(Long employeeID) {
    this.employeeID = employeeID;
  }

  public String getUsername() {
    return username;
  }

  public void setUsername(String username) {
    this.username = username;
  }

  public String getEmail() {
    return email;
  }

  public void setEmail(String email) {
    this.email = email;
  }

  public String getPassword() {
    return password;
  }

  public void setPassword(String password) {
    this.password = password;
  }

  public Set<Role> getRoles() {
    return roles;
  }

  public void setRoles(Set<Role> roles) {
    this.roles = roles;
  }

public String getFirstName() {
	return firstName;
}

public void setFirstName(String firstName) {
	this.firstName = firstName;
}

public String getLastName() {
	return lastName;
}

public void setLastName(String lastName) {
	this.lastName = lastName;
}
}



ERole.java:

package com.crm.wm.entities;

public enum ERole {
    ROLE_USER,
    ROLE_MODERATOR,
    ROLE_ADMIN
}



Invoice.java:

package com.crm.wm.entities;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.ToString;

import java.util.Date;
import java.util.List;

@AllArgsConstructor
@NoArgsConstructor
@ToString
@Entity
@Table(name = "Invoices")
@Data
public class Invoice {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long invoiceID;

    @ManyToOne
    @JoinColumn(name = "CustomerID")
    private Customer customer;

    @ManyToOne
    @JoinColumn(name = "EmployeeID")
    private Employee employee;

    private Date invoiceDate;

    private Date month;

    private Double totalAmount;

    @OneToMany(mappedBy = "invoice")
    private List<InvoiceItem> invoiceItems;

    // Other fields, constructors, getters, setters
}



InvoiceItem.java:

package com.crm.wm.entities;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.ToString;

@AllArgsConstructor
@NoArgsConstructor
@ToString
@Entity
@Table(name = "InvoiceItems")
@Data
public class InvoiceItem {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long invoiceItemID;

    @ManyToOne
    @JoinColumn(name = "InvoiceID")
    private Invoice invoice;

    @ManyToOne
    @JoinColumn(name = "ProductID")
    private Product product;

    private Double price;
    private Integer quantity;
    private Double totalPrice;

    // Other fields, constructors, getters, setters
}



Municipality.java:

package com.crm.wm.entities;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.ToString;

import java.util.List;

@AllArgsConstructor
@NoArgsConstructor
@ToString
@Entity
@Getter
@Setter
@Table(name = "Municipalities")
@Data
public class Municipality {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long municipalityID;

    private String municipalityName;

    @OneToMany(mappedBy = "municipality")
    private List<Customer> customers;

    @OneToMany(mappedBy = "municipality")
    private List<Product> products;

    // Other fields, constructors, getters, setters
}



Product.java:

package com.crm.wm.entities;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.ToString;

@AllArgsConstructor
@NoArgsConstructor
@ToString
@Entity
@Table(name = "Products")
@Data
public class Product {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long productID;

    private String productName;
    private String description;
    private Double price;

    // Define the relationship with Customer
    @ManyToOne
    @JoinColumn(name = "customerID")
    private Customer customer;

    @ManyToOne
    @JoinColumn(name = "MunicipalityID")
    private Municipality municipality;

    // Other fields, constructors, getters, setters
}



Role.java:

package com.crm.wm.entities;

import jakarta.persistence.*;

@Entity
@Table(name = "roles")
public class Role {
  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Integer id;

  @Enumerated(EnumType.STRING)
  @Column(length = 20)
  private ERole name;

  public Role() {

  }

  public Role(ERole name) {
    this.name = name;
  }

  public Integer getId() {
    return id;
  }

  public void setId(Integer id) {
    this.id = id;
  }

  public ERole getName() {
    return name;
  }

  public void setName(ERole name) {
    this.name = name;
  }
}



CustomerRepository.java:

package com.crm.wm.repository;

import com.crm.wm.entities.Customer;
import org.springframework.data.jpa.repository.JpaRepository;

public interface CustomerRepository extends JpaRepository<Customer, Long> {
    // Add custom queries if needed
}



CustomerJdbcRepository.java:

package com.crm.wm.repository;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

@Repository
public class CustomerJdbcRepository {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    // Add JDBC queries if needed
}



EmployeeRepository.java:

package com.crm.wm.repository;

import java.util.List;
import java.util.Optional;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.stereotype.Repository;
import com.crm.wm.entities.Employee;


@Repository
public interface EmployeeRepository extends JpaRepository<Employee, Long> {
  Optional<Employee> findByUsername(String username);

  Boolean existsByUsername(String username);

  Boolean existsByEmail(String email);

//find employees by role name
  @Query("SELECT e FROM Employee e JOIN e.roles r WHERE r.name = ?1")
  List<Employee> findByRoleName(String roleName);

  // find employees by first name or last name containing a keyword
  List<Employee> findByFirstNameContainingOrLastNameContaining(String keyword1, String keyword2);
}



MunicipalityRepository.java:

package com.crm.wm.repository;

import com.crm.wm.entities.Municipality;

import java.util.List;

public interface MunicipalityRepository {
    Municipality create (Municipality municipality);

    List<Municipality> readAll();

    Municipality update (Municipality municipality);

    boolean delete(Long municipalityID);
}



JdbcMunicipalityRepository.java:

package com.crm.wm.repository;

import com.crm.wm.entities.Municipality;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.BeanPropertyRowMapper;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public class JdbcMunicipalityRepository implements MunicipalityRepository {

    private static final String INSERT_MUNICIPALITY_QUERY = "INSERT INTO Municipalities (municipality_name) VALUES(?)";

    private static final String SELECT_ALL_MUNICIPALITY_QUERY = "SELECT * FROM Municipalities";
    private static final String UPDATE_MUNICIPALITY_BY_ID_QUERY = "UPDATE Municipalities SET municipality_name=? WHERE municipalityID=?";

    private static final String DELETE_MUNICIPALITY_BY_ID_QUERY = "DELETE FROM Municipalities WHERE MunicipalityID = ?";

    @Autowired
    private JdbcTemplate jdbcTemplate;

    @Override
    public Municipality create(Municipality municipality) {
        // Implement the logic to create a municipality using JdbcTemplate
        jdbcTemplate.update(INSERT_MUNICIPALITY_QUERY, municipality.getMunicipalityName());
        return municipality;
    }

    @Override
    public List<Municipality> readAll() {
        // Implement the logic to read all municipalities using JdbcTemplate
        return jdbcTemplate.query(SELECT_ALL_MUNICIPALITY_QUERY, new BeanPropertyRowMapper<>(Municipality.class));
    }

    @Override
    public Municipality update(Municipality municipality) {
        // Implement the logic to update a municipality using JdbcTemplate
        jdbcTemplate.update(UPDATE_MUNICIPALITY_BY_ID_QUERY, municipality.getMunicipalityName(), municipality.getMunicipalityID());
        return municipality;
    }

    @Override
    public boolean delete(Long municipalityID) {
        // Implement the logic to delete a municipality using JdbcTemplate
        int rowsAffected = jdbcTemplate.update(DELETE_MUNICIPALITY_BY_ID_QUERY, municipalityID);

        return rowsAffected > 0;
    }
}



ProductRepository.java:

package com.crm.wm.repository;

import com.crm.wm.entities.Customer;
import com.crm.wm.entities.Product;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface ProductRepository extends JpaRepository<Product, Long> {
    // You can add custom queries or methods if needed
    List<Product> findByCustomer(Customer customer);
}



RoleRepository.java:

package com.crm.wm.repository;

import java.util.Optional;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import com.crm.wm.entities.ERole;
import com.crm.wm.entities.Role;


@Repository
public interface RoleRepository extends JpaRepository<Role, Long> {
  Optional<Role> findByName(ERole name);
}



InvoiceRepository.java:

package com.crm.wm.repository;

import com.crm.wm.entities.Customer;
import com.crm.wm.entities.Invoice;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Date;

@Repository
public interface InvoiceRepository extends JpaRepository<Invoice, Long> {
    // You can add custom queries if needed

    boolean existsByCustomerAndInvoiceDate(Customer customer, Date invoiceDate);
    boolean existsByCustomerAndMonth(Customer customer, Date month);
}



ProductService.java:

package com.crm.wm.services;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import com.crm.wm.entities.Customer;
import com.crm.wm.entities.Product;
import com.crm.wm.repository.ProductRepository;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Service
public class ProductService {

    @Autowired
    private ProductRepository productRepository;

    // Other dependencies...

    public Map<Long, Double> getPricesForProductsAssociatedWithCustomer(Customer customer) {
        // Assuming you have a method in the ProductRepository to fetch products associated with a customer
        List<Product> products = productRepository.findByCustomer(customer);

        // Assuming each product has a price field
        Map<Long, Double> productPrices = new HashMap<>();
        for (Product product : products) {
            productPrices.put(product.getProductID(), product.getPrice());
        }
        return productPrices;
    }

    // Other methods...
}




CustomerProductAssociationRequest.java:

package com.crm.wm.dto;

import com.crm.wm.entities.Customer;

import java.util.List;

public class CustomerProductAssociationRequest {

    private Customer customer;
    private List<Long> productIds;

    // Constructors, getters, and setters

    public CustomerProductAssociationRequest() {
    }

    public CustomerProductAssociationRequest(Customer customer, List<Long> productIds) {
        this.customer = customer;
        this.productIds = productIds;
    }

    public Customer getCustomer() {
        return customer;
    }

    public void setCustomer(Customer customer) {
        this.customer = customer;
    }

    public List<Long> getProductIds() {
        return productIds;
    }

    public void setProductIds(List<Long> productIds) {
        this.productIds = productIds;
    }
}



ProductWithQuantity.java:

package com.crm.wm.services;

import com.crm.wm.entities.Product;

public class ProductWithQuantity {

    private Product product;
    private int quantity;

    public ProductWithQuantity(Product product, int quantity) {
        this.product = product;
        this.quantity = quantity;
    }

    // Getters and setters
    public Product getProduct() {
        return product;
    }

    public void setProduct(Product product) {
        this.product = product;
    }

    public int getQuantity() {
        return quantity;
    }

    public void setQuantity(int quantity) {
        this.quantity = quantity;
    }
}



InvoiceGenerationService.java:

package com.crm.wm.services;

import com.crm.wm.entities.Customer;
import com.crm.wm.entities.Invoice;
import com.crm.wm.entities.Product;
import com.crm.wm.repository.CustomerRepository;
import com.crm.wm.repository.InvoiceRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Collections;
import java.util.List;

@Service
public class InvoiceGenerationService {

    @Autowired
    private InvoiceRepository invoiceRepository;

    @Autowired
    private CustomerRepository customerRepository;

    // Other dependencies...

    @Transactional
    public void generateInvoices() {
        // Logic to fetch customers and generate invoices based on associated products
        List<Customer> customers = customerRepository.findAll();
        for (Customer customer : customers) {
            Invoice invoice = new Invoice();
            invoice.setCustomer(customer);

            // Calculate the total amount based on the customer's associated products
            double totalAmount = calculateTotalAmount(customer.getProducts());

            // Add additional products (expenses) for the month
            List<Product> additionalProducts = getAdditionalProductsForCustomer(customer);
            totalAmount += calculateTotalAmount(additionalProducts);

            invoice.setTotalAmount(totalAmount);

            // Save the invoice
            invoiceRepository.save(invoice);
        }
    }

    private double calculateTotalAmount(List<Product> products) {
        // Calculate the total amount based on the products
        // You can implement your specific logic here
        // For example, summing the prices of all products
        return products.stream()
                .mapToDouble(Product::getPrice)
                .sum();
    }

    private List<Product> getAdditionalProductsForCustomer(Customer customer) {
        // Logic to fetch additional products (expenses) for the customer for the month
        // You may retrieve these from a repository or another data source
        // For demonstration purposes, return an empty list
        return Collections.emptyList();
    }
}



InvoiceGenerationException.java:

package com.crm.wm.services;

public class InvoiceGenerationException extends RuntimeException {

    public InvoiceGenerationException(String message) {
        super(message);
    }
}



InvoiceRequest.java:

package com.crm.wm.services;

import lombok.AllArgsConstructor;
import lombok.NoArgsConstructor;
import lombok.ToString;

import java.util.Date;
import java.util.List;

@AllArgsConstructor
@NoArgsConstructor
@ToString
public class InvoiceRequest {
    public Long getCustomerId() {
        return customerId;
    }

    public void setCustomerId(Long customerId) {
        this.customerId = customerId;
    }

    public Long getEmployeeId() {
        return employeeId;
    }

    public void setEmployeeId(Long employeeId) {
        this.employeeId = employeeId;
    }

    public Date getMonth() {
        return month;
    }

    public void setMonth(Date month) {
        this.month = month;
    }

    public List<Long> getProductIds() {
        return productIds;
    }

    public void setProductIds(List<Long> productIds) {
        this.productIds = productIds;
    }

    public List<Integer> getQuantities() {
        return quantities;
    }

    public void setQuantities(List<Integer> quantities) {
        this.quantities = quantities;
    }

    private Long customerId;
    private Long employeeId;
    private Date month;
    private List<Long> productIds;
    private List<Integer> quantities;

    // Getters and setters
}



InvoiceService.java:

package com.crm.wm.services;

import com.crm.wm.entities.*;
import com.crm.wm.repository.EmployeeRepository;
import com.crm.wm.repository.InvoiceRepository;
import jakarta.persistence.EntityNotFoundException;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Calendar;
import java.util.Date;
import java.util.List;
import java.util.Map;

@Service
public class InvoiceService {

    @Autowired
    private InvoiceRepository invoiceRepository;

    @Autowired
    private EmployeeRepository employeeRepository;

    @Autowired
    private ProductService productService;

    // Other dependencies...

    @Transactional
    public Invoice generateInvoiceManually(Customer customer, Date invoiceDate, Long employeeId, Date month, List<ProductWithQuantity> productsWithQuantity) {
        // Set invoiceDate to current date if not provided
        if (invoiceDate == null) {
            invoiceDate = Calendar.getInstance().getTime();
        }

        // Check if an invoice for the given month already exists
        if (invoiceRepository.existsByCustomerAndMonth(customer, month)) {
            throw new InvoiceGenerationException("Invoice already generated for the specified month.");
        }

        // Fetch employee details
        Employee employee = employeeRepository.findById(employeeId)
                .orElseThrow(() -> new EntityNotFoundException("Employee not found"));

        // Fetch prices of products associated with the customer
        Map<Long, Double> productPrices = productService.getPricesForProductsAssociatedWithCustomer(customer);

        // Logic to generate the invoice manually
        Invoice invoice = new Invoice();
        invoice.setCustomer(customer);
        invoice.setEmployee(employee); // Set the employee generating the invoice
        invoice.setMonth(month); // Set the month of the invoice
        invoice.setInvoiceDate(new Date()); // Set the current date as the invoice date, you can modify this as needed

        // Create InvoiceItem objects for each product and add them to the invoice
        double totalAmount = 0.0;
        for (ProductWithQuantity productWithQuantity : productsWithQuantity) {
            Product product = productWithQuantity.getProduct();
            int quantity = productWithQuantity.getQuantity();

            for (int i = 0; i < quantity; i++) {
                InvoiceItem invoiceItem = new InvoiceItem();
                invoiceItem.setProduct(product);
                invoiceItem.setQuantity(1); // Default quantity to 1

                // Set product price based on association with the customer
                if (productPrices.containsKey(product.getProductID())) {
                    double price = productPrices.get(product.getProductID());
                    invoiceItem.setPrice(price);
                    totalAmount += price;
                } else {
                    // Handle scenario where price is not available for the product
                    // You can throw an exception or set a default price
                }

                // Set other invoice item details as needed
                invoice.getInvoiceItems().add(invoiceItem);
            }
        }

        // Set total amount for the invoice
        invoice.setTotalAmount(totalAmount);

        // Save the manually generated invoice
        return invoiceRepository.save(invoice);
    }

    public boolean isInvoiceGeneratedForMonth(Customer customer, Date invoiceMonth) {
        return invoiceRepository.existsByCustomerAndMonth(customer, invoiceMonth);
    }
}



WebSecurityConfig.java:

package com.crm.wm.security;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

import com.crm.wm.security.jwt.AuthEntryPointJwt;
import com.crm.wm.security.jwt.AuthTokenFilter;
import com.crm.wm.security.services.UserDetailsServiceImpl;


@Configuration
@EnableMethodSecurity
// (securedEnabled = true,
// jsr250Enabled = true,
// prePostEnabled = true) // by default
public class WebSecurityConfig { // extends WebSecurityConfigurerAdapter {
  @Autowired
  UserDetailsServiceImpl userDetailsService;

  @Autowired
  private AuthEntryPointJwt unauthorizedHandler;

  @Bean
  public AuthTokenFilter authenticationJwtTokenFilter() {
    return new AuthTokenFilter();
  }

  @Bean
  public DaoAuthenticationProvider authenticationProvider() {
      DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();

      authProvider.setUserDetailsService(userDetailsService);
      authProvider.setPasswordEncoder(passwordEncoder());

      return authProvider;
  }

  @Bean
  public AuthenticationManager authenticationManager(AuthenticationConfiguration authConfig) throws Exception {
    return authConfig.getAuthenticationManager();
  }

  @Bean
  public PasswordEncoder passwordEncoder() {
    return new BCryptPasswordEncoder();
  }

  @Bean
  public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
    http.csrf(csrf -> csrf.disable())
        .exceptionHandling(exception -> exception.authenticationEntryPoint(unauthorizedHandler))
        .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
        .authorizeHttpRequests(auth ->
          auth.requestMatchers("/api/auth/**").permitAll()
              .requestMatchers("/api/test/**").permitAll()
              .anyRequest().authenticated()
        );

    http.authenticationProvider(authenticationProvider());

    http.addFilterBefore(authenticationJwtTokenFilter(), UsernamePasswordAuthenticationFilter.class);

    return http.build();
  }
}



UserDetailsImpl.java:

package com.crm.wm.security.services;

import java.util.Collection;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

import com.crm.wm.entities.Employee;
import com.fasterxml.jackson.annotation.JsonIgnore;

public class UserDetailsImpl implements UserDetails {
	  private static final long serialVersionUID = 1L;

	  private Long id;

	  private String username;

	  private String email;

	  @JsonIgnore
	  private String password;

	  private Collection<? extends GrantedAuthority> authorities;

	  public UserDetailsImpl(Long id, String username, String email, String password,
	      Collection<? extends GrantedAuthority> authorities) {
	    this.id = id;
	    this.username = username;
	    this.email = email;
	    this.password = password;
	    this.authorities = authorities;
	  }

	  public static UserDetailsImpl build(Employee employee) {
	    List<GrantedAuthority> authorities = employee.getRoles().stream()
	        .map(role -> new SimpleGrantedAuthority(role.getName().name()))
	        .collect(Collectors.toList());

	    return new UserDetailsImpl(
	    		employee.getId(),
	    		employee.getUsername(),
	    		employee.getEmail(),
	    		employee.getPassword(),
	        authorities);
	  }

	  @Override
	  public Collection<? extends GrantedAuthority> getAuthorities() {
	    return authorities;
	  }

	  public Long getId() {
	    return id;
	  }

	  public String getEmail() {
	    return email;
	  }

	  @Override
	  public String getPassword() {
	    return password;
	  }

	  @Override
	  public String getUsername() {
	    return username;
	  }

	  @Override
	  public boolean isAccountNonExpired() {
	    return true;
	  }

	  @Override
	  public boolean isAccountNonLocked() {
	    return true;
	  }

	  @Override
	  public boolean isCredentialsNonExpired() {
	    return true;
	  }

	  @Override
	  public boolean isEnabled() {
	    return true;
	  }

	  @Override
	  public boolean equals(Object o) {
	    if (this == o)
	      return true;
	    if (o == null || getClass() != o.getClass())
	      return false;
	    UserDetailsImpl user = (UserDetailsImpl) o;
	    return Objects.equals(id, user.id);
	  }
	}



UserDetailsServiceImpl.java:

package com.crm.wm.security.services;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.crm.wm.entities.Employee;
import com.crm.wm.repository.EmployeeRepository;

@Service
public class UserDetailsServiceImpl implements UserDetailsService {
  @Autowired
  EmployeeRepository employeeRepository;

  @Override
  @Transactional
  public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
	  Employee employee = employeeRepository.findByUsername(username)
        .orElseThrow(() -> new UsernameNotFoundException("User Not Found with username: " + username));

    return UserDetailsImpl.build(employee);
  }

}



AuthEntryPointJwt.java:

package com.crm.wm.security.jwt;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.MediaType;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.AuthenticationEntryPoint;
import org.springframework.stereotype.Component;

import com.fasterxml.jackson.databind.ObjectMapper;

@Component
public class AuthEntryPointJwt implements AuthenticationEntryPoint {

  private static final Logger logger = LoggerFactory.getLogger(AuthEntryPointJwt.class);

  @Override
  public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException)
      throws IOException, ServletException {
    logger.error("Unauthorized error: {}", authException.getMessage());

    response.setContentType(MediaType.APPLICATION_JSON_VALUE);
    response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);

    final Map<String, Object> body = new HashMap<>();
    body.put("status", HttpServletResponse.SC_UNAUTHORIZED);
    body.put("error", "Unauthorized");
    body.put("message", authException.getMessage());
    body.put("path", request.getServletPath());

    final ObjectMapper mapper = new ObjectMapper();
    mapper.writeValue(response.getOutputStream(), body);
  }
}



AuthTokenFilter.java:

package com.crm.wm.security.jwt;

import java.io.IOException;

import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.util.StringUtils;
import org.springframework.web.filter.OncePerRequestFilter;

import com.crm.wm.security.services.UserDetailsServiceImpl;

public class AuthTokenFilter extends OncePerRequestFilter {
	  @Autowired
	  private JwtUtils jwtUtils;

	  @Autowired
	  private UserDetailsServiceImpl userDetailsService;

	  private static final Logger logger = LoggerFactory.getLogger(AuthTokenFilter.class);

	  @Override
	  protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
	      throws ServletException, IOException {
	    try {
	      String jwt = parseJwt(request);
	      if (jwt != null && jwtUtils.validateJwtToken(jwt)) {
	        String username = jwtUtils.getUserNameFromJwtToken(jwt);

	        UserDetails userDetails = userDetailsService.loadUserByUsername(username);
	        UsernamePasswordAuthenticationToken authentication =
	            new UsernamePasswordAuthenticationToken(
	                userDetails,
	                null,
	                userDetails.getAuthorities());
	        authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));

	        SecurityContextHolder.getContext().setAuthentication(authentication);
	      }
	    } catch (Exception e) {
	      logger.error("Cannot set user authentication: {}", e);
	    }

	    filterChain.doFilter(request, response);
	  }

	  private String parseJwt(HttpServletRequest request) {
	    String headerAuth = request.getHeader("Authorization");

	    if (StringUtils.hasText(headerAuth) && headerAuth.startsWith("Bearer ")) {
	      return headerAuth.substring(7);
	    }

	    return null;
	  }
	}



JwtUtils.java:

package com.crm.wm.security.jwt;

import java.security.Key;
import java.util.Date;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.Authentication;
import org.springframework.stereotype.Component;

import com.crm.wm.security.services.UserDetailsImpl;

import io.jsonwebtoken.*;
import io.jsonwebtoken.io.Decoders;
import io.jsonwebtoken.security.Keys;

@Component
public class JwtUtils {
  private static final Logger logger = LoggerFactory.getLogger(JwtUtils.class);

  @Value("${wm.app.jwtSecret}")
  private String jwtSecret;

  @Value("${wm.app.jwtExpirationMs}")
  private int jwtExpirationMs;

  public String generateJwtToken(Authentication authentication) {

	    UserDetailsImpl userPrincipal = (UserDetailsImpl) authentication.getPrincipal();

	    return Jwts.builder()
	        .setSubject(userPrincipal.getUsername())
	        .setIssuedAt(new Date())
	        .setExpiration(new Date(System.currentTimeMillis() + jwtExpirationMs))
	        .signWith(key(), SignatureAlgorithm.HS256)
	        .compact();
	  }

	  private Key key() {
	    return Keys.hmacShaKeyFor(Decoders.BASE64.decode(jwtSecret));
	  }

	  public String getUserNameFromJwtToken(String token) {
	    return Jwts.parser().setSigningKey(key()).build().parseSignedClaims(token).getPayload().getSubject();
	  }

	  public boolean validateJwtToken(String authToken) {
	    try {
	      Jwts.parser().setSigningKey(key()).build().parseSignedClaims(authToken);
	      return true;
	    } catch (MalformedJwtException e) {
	      logger.error("Invalid JWT token: {}", e.getMessage());
	    } catch (ExpiredJwtException e) {
	      logger.error("JWT token is expired: {}", e.getMessage());
	    } catch (UnsupportedJwtException e) {
	      logger.error("JWT token is unsupported: {}", e.getMessage());
	    } catch (IllegalArgumentException e) {
	      logger.error("JWT claims string is empty: {}", e.getMessage());
	    }

	    return false;
	  }
	}



LoginRequest.java:

package com.crm.wm.payload.request;

import jakarta.validation.constraints.NotBlank;

public class LoginRequest {
	@NotBlank
  private String username;

	@NotBlank
	private String password;

	public String getUsername() {
		return username;
	}

	public void setUsername(String username) {
		this.username = username;
	}

	public String getPassword() {
		return password;
	}

	public void setPassword(String password) {
		this.password = password;
	}
}



SignupRequest.java:

package com.crm.wm.payload.request;

import java.util.Set;

import jakarta.validation.constraints.*;

public class SignupRequest {
  @NotBlank
  @Size(min = 3, max = 20)
  private String username;

  @NotBlank
  @Size(max = 50)
  @Email
  private String email;

  private Set<String> role;

  @NotBlank
  @Size(min = 6, max = 40)
  private String password;

  public String getUsername() {
    return username;
  }

  public void setUsername(String username) {
    this.username = username;
  }

  public String getEmail() {
    return email;
  }

  public void setEmail(String email) {
    this.email = email;
  }

  public String getPassword() {
    return password;
  }

  public void setPassword(String password) {
    this.password = password;
  }

  public Set<String> getRole() {
    return this.role;
  }

  public void setRole(Set<String> role) {
    this.role = role;
  }
}



JwtResponse.java:

package com.crm.wm.payload.response;

import java.util.List;

public class JwtResponse {
  private String token;
  private String type = "Bearer";
  private Long id;
  private String username;
  private String email;
  private List<String> roles;

  public JwtResponse(String accessToken, Long id, String username, String email, List<String> roles) {
    this.token = accessToken;
    this.id = id;
    this.username = username;
    this.email = email;
    this.roles = roles;
  }

  public String getAccessToken() {
    return token;
  }

  public void setAccessToken(String accessToken) {
    this.token = accessToken;
  }

  public String getTokenType() {
    return type;
  }

  public void setTokenType(String tokenType) {
    this.type = tokenType;
  }

  public Long getId() {
    return id;
  }

  public void setId(Long id) {
    this.id = id;
  }

  public String getEmail() {
    return email;
  }

  public void setEmail(String email) {
    this.email = email;
  }

  public String getUsername() {
    return username;
  }

  public void setUsername(String username) {
    this.username = username;
  }

  public List<String> getRoles() {
    return roles;
  }
}



MessageResponse.java:

package com.crm.wm.payload.response;

public class MessageResponse {
	  private String message;

	  public MessageResponse(String message) {
	    this.message = message;
	  }

	  public String getMessage() {
	    return message;
	  }

	  public void setMessage(String message) {
	    this.message = message;
	  }
	}



AuthController.java:

package com.crm.wm.controllers;

import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

import jakarta.validation.Valid;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import com.crm.wm.entities.ERole;
import com.crm.wm.entities.Role;
import com.crm.wm.entities.Employee;
import com.crm.wm.dto.request.payload.LoginRequest;
import com.crm.wm.dto.request.payload.SignupRequest;
import com.crm.wm.dto.response.payload.JwtResponse;
import com.crm.wm.dto.response.payload.MessageResponse;
import com.crm.wm.repository.RoleRepository;
import com.crm.wm.repository.EmployeeRepository;
import com.crm.wm.security.jwt.JwtUtils;
import com.crm.wm.security.services.UserDetailsImpl;

@CrossOrigin(origins = "*", maxAge = 3600)
@RestController
@RequestMapping("/api/auth")
public class AuthController {
  @Autowired
  AuthenticationManager authenticationManager;

  @Autowired
  EmployeeRepository employeeRepository;

  @Autowired
  RoleRepository roleRepository;

  @Autowired
  PasswordEncoder encoder;

  @Autowired
  JwtUtils jwtUtils;

  @PostMapping("/signin")
  public ResponseEntity<?> authenticateUser(@Valid @RequestBody LoginRequest loginRequest) {

    Authentication authentication = authenticationManager.authenticate(
        new UsernamePasswordAuthenticationToken(loginRequest.getUsername(), loginRequest.getPassword()));

    SecurityContextHolder.getContext().setAuthentication(authentication);
    String jwt = jwtUtils.generateJwtToken(authentication);

    UserDetailsImpl userDetails = (UserDetailsImpl) authentication.getPrincipal();
    List<String> roles = userDetails.getAuthorities().stream()
        .map(item -> item.getAuthority())
        .collect(Collectors.toList());

    return ResponseEntity.ok(new JwtResponse(jwt,
                         userDetails.getId(),
                         userDetails.getUsername(),
                         userDetails.getEmail(),
                         roles));
  }

  @PostMapping("/signup")
  public ResponseEntity<?> registerUser(@Valid @RequestBody SignupRequest signUpRequest) {
    if (employeeRepository.existsByUsername(signUpRequest.getUsername())) {
      return ResponseEntity
          .badRequest()
          .body(new MessageResponse("Error: Username is already taken!"));
    }

    if (employeeRepository.existsByEmail(signUpRequest.getEmail())) {
      return ResponseEntity
          .badRequest()
          .body(new MessageResponse("Error: Email is already in use!"));
    }

    // Create new user's account
    Employee employee = new Employee(signUpRequest.getUsername(),
               signUpRequest.getEmail(),
               encoder.encode(signUpRequest.getPassword()));

    Set<String> strRoles = signUpRequest.getRole();
    Set<Role> roles = new HashSet<>();

    if (strRoles == null) {
      Role userRole = roleRepository.findByName(ERole.ROLE_USER)
          .orElseThrow(() -> new RuntimeException("Error: Role is not found."));
      roles.add(userRole);
    } else {
      strRoles.forEach(role -> {
        switch (role) {
        case "admin":
          Role adminRole = roleRepository.findByName(ERole.ROLE_ADMIN)
              .orElseThrow(() -> new RuntimeException("Error: Role is not found."));
          roles.add(adminRole);

          break;
        case "mod":
          Role modRole = roleRepository.findByName(ERole.ROLE_MODERATOR)
              .orElseThrow(() -> new RuntimeException("Error: Role is not found."));
          roles.add(modRole);

          break;
        default:
          Role userRole = roleRepository.findByName(ERole.ROLE_USER)
              .orElseThrow(() -> new RuntimeException("Error: Role is not found."));
          roles.add(userRole);
        }
      });
    }

    employee.setRoles(roles);
    employeeRepository.save(employee);

    return ResponseEntity.ok(new MessageResponse("User registered successfully!"));
  }
}



TestController.java:

package com.crm.wm.controllers;

import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@CrossOrigin(origins = "*", maxAge = 3600)
@RestController
@RequestMapping("/api/test")
public class TestController {
  @GetMapping("/all")
  public String allAccess() {
    return "Public Content.";
  }

  @GetMapping("/user")
  @PreAuthorize("hasRole('USER') or hasRole('MODERATOR') or hasRole('ADMIN')")
  public String userAccess() {
    return "User Content.";
  }

  @GetMapping("/mod")
  @PreAuthorize("hasRole('MODERATOR')")
  public String moderatorAccess() {
    return "Moderator Board.";
  }

  @GetMapping("/admin")
  @PreAuthorize("hasRole('ADMIN')")
  public String adminAccess() {
    return "Admin Board.";
  }
}



CustomerController.java:

package com.crm.wm.controllers;

import com.crm.wm.dto.CustomerProductAssociationRequest;
import com.crm.wm.entities.Company;
import com.crm.wm.entities.Customer;
import com.crm.wm.entities.CustomerType;
import com.crm.wm.entities.Product;
import com.crm.wm.repository.CustomerJdbcRepository;
import com.crm.wm.repository.CustomerRepository;
import com.crm.wm.repository.ProductRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Optional;

@RestController
@RequestMapping("/api/customers")
public class CustomerController {

    @Autowired
    private CustomerRepository customerRepository;

    @Autowired
    private CustomerJdbcRepository customerJdbcRepository;

    @Autowired
    private ProductRepository productRepository;

    // Add CRUD operations and custom endpoints
    @PreAuthorize("hasRole('USER') or hasRole('MODERATOR') or hasRole('ADMIN')")
    @PostMapping("/")
    public ResponseEntity<?> createCustomer(@RequestBody CustomerProductAssociationRequest request) {
        Customer customer = request.getCustomer();
        List<Long> productIds = request.getProductIds();

        // Fetch the customer from the request
        if (customer == null) {
            return ResponseEntity.badRequest().body("Customer details are required.");
        }

        // Check if customer type is INDIVIDUAL and there are company details
        if (customer.getCustomerType() == CustomerType.INDIVIDUAL && customer.getCompany() != null) {
            return ResponseEntity.badRequest().body("Individual customer cannot have company details.");
        }

        // Fetch products by their IDs
        List<Product> products = productRepository.findAllById(productIds); // Assuming productService is available

        // Associate the products with the customer
        customer.setProducts(products);
        customerRepository.save(customer);

        return ResponseEntity.ok("Customer saved and all products associated with the customer successfully.");
    }

    @PreAuthorize("hasRole('USER') or hasRole('MODERATOR') or hasRole('ADMIN')")
    @PutMapping("/{customerId}")
    public ResponseEntity<Customer> updateCustomer(@PathVariable Long customerId, @RequestBody Customer updatedCustomer) {
        Optional<Customer> existingCustomerOptional = customerRepository.findById(customerId);

        if (existingCustomerOptional.isPresent()) {
            Customer existingCustomer = existingCustomerOptional.get();

            // Update customer fields
            existingCustomer.setFirstName(updatedCustomer.getFirstName());
            existingCustomer.setLastName(updatedCustomer.getLastName());
            existingCustomer.setEmail(updatedCustomer.getEmail());
            existingCustomer.setPhoneNumber(updatedCustomer.getPhoneNumber());
            existingCustomer.setAddress(updatedCustomer.getAddress());
            existingCustomer.setMunicipality(updatedCustomer.getMunicipality());
            existingCustomer.setCustomerType(updatedCustomer.getCustomerType());

            // Update associated company information
            Company existingCompany = existingCustomer.getCompany();
            Company updatedCompany = updatedCustomer.getCompany();

            if (existingCompany != null && updatedCompany != null) {
                existingCompany.setCompanyName(updatedCompany.getCompanyName());
                // Update other company fields as needed
            } else if (existingCompany == null && updatedCompany != null) {
                updatedCompany.setCustomer(existingCustomer);
                existingCustomer.setCompany(updatedCompany);
            } else if (existingCompany != null && updatedCompany == null) {
                existingCompany.setCustomer(null);
                existingCustomer.setCompany(null);
            }

            // Save the updated customer
            Customer savedCustomer = customerRepository.save(existingCustomer);

            return new ResponseEntity<>(savedCustomer, HttpStatus.OK);
        } else {
            return new ResponseEntity<>(HttpStatus.NOT_FOUND);
        }

    }
    // Add more endpoints as needed
}



MunicipalityController.java:

package com.crm.wm.controllers;

import com.crm.wm.entities.Municipality;
import com.crm.wm.repository.MunicipalityRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@CrossOrigin(origins = "*")
@RestController
@RequestMapping("/api/municipalities")
public class MunicipalityController {

    @Autowired
    MunicipalityRepository municipalityRepository;

    @PreAuthorize("hasRole('MODERATOR') or hasRole('ADMIN')")
    @PostMapping("/")
    public Municipality createMunicipality(@RequestBody Municipality municipality) {
        return municipalityRepository.create(municipality);
    }

    @PreAuthorize("hasRole('USER') or hasRole('MODERATOR') or hasRole('ADMIN')")
    @GetMapping("/")
    public List<Municipality> readAllMunicipalities() {
        return municipalityRepository.readAll();
    }

    @PreAuthorize("hasRole('MODERATOR') or hasRole('ADMIN')")
    @PutMapping("/{municipalityID}")
    public Municipality updateMunicipality(@PathVariable Long municipalityID, @RequestBody Municipality municipality) {
        municipality.setMunicipalityID(municipalityID);
        return municipalityRepository.update(municipality);
    }

    @PreAuthorize("hasRole('ADMIN')")
    @DeleteMapping("/{municipalityID}")
    public String deleteMunicipality(@PathVariable Long municipalityID) {
        boolean deleted = municipalityRepository.delete(municipalityID);

        if (deleted) {
            return "Municipality deleted successfully.";
        } else {
            return "Municipality not found or delete failed.";
        }
    }
}



ProductController.java:

package com.crm.wm.controllers;

import com.crm.wm.entities.Product;
import com.crm.wm.repository.ProductRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/products")
public class ProductController {

    @Autowired
    private ProductRepository productRepository;

    // Other autowired dependencies...

    @PreAuthorize("hasRole('MODERATOR') or hasRole('ADMIN')")
    @GetMapping("/")
    public List<Product> getAllProducts() {
        return productRepository.findAll();
    }

    @PreAuthorize("hasRole('MODERATOR') or hasRole('ADMIN')")
    @PostMapping("/")
    public ResponseEntity<Product> createProduct(@RequestBody Product product) {
        Product createdProduct = productRepository.save(product);
        return ResponseEntity.ok(createdProduct);
    }

    // You can add more CRUD operations or custom endpoints as needed
}



InvoiceController.java:

package com.crm.wm.controllers;

import com.crm.wm.entities.Customer;
import com.crm.wm.entities.Invoice;
import com.crm.wm.entities.Product;
import com.crm.wm.repository.CustomerRepository;
import com.crm.wm.repository.ProductRepository;
import com.crm.wm.services.InvoiceGenerationException;
import com.crm.wm.services.InvoiceRequest;
import com.crm.wm.services.InvoiceService;
import com.crm.wm.services.ProductWithQuantity;
import jakarta.persistence.EntityNotFoundException;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.Date;
import java.util.List;

@RestController
@RequestMapping("/api/invoices")
public class InvoiceController {

    @Autowired
    private InvoiceService invoiceService;

    @Autowired
    private CustomerRepository customerRepository;

    @Autowired
    private ProductRepository productRepository;

    @PreAuthorize("hasRole('USER') or hasRole('MODERATOR') or hasRole('ADMIN')")
    @PostMapping("/generate")
    public ResponseEntity<String> generateInvoiceManually(@RequestBody InvoiceRequest invoiceRequest) {
        // Extract data from the request object
        Long customerId = invoiceRequest.getCustomerId();
        Long employeeId = invoiceRequest.getEmployeeId();
        Date month = invoiceRequest.getMonth();
        List<Long> productIds = invoiceRequest.getProductIds();
        List<Integer> quantities = invoiceRequest.getQuantities();

        Customer customer = customerRepository.findById(customerId)
                .orElseThrow(() -> new EntityNotFoundException("Customer not found"));

        try {
            // Fetch products based on provided productIds
            List<Product> products = productRepository.findAllById(productIds);

            // Prepare products with quantities
            List<ProductWithQuantity> productsWithQuantity;
            if (quantities != null && quantities.size() == productIds.size()) {
                productsWithQuantity = InvoiceControllerUtil.mapProductsWithQuantities(products, quantities);
            } else {
                productsWithQuantity = InvoiceControllerUtil.mapProductsWithQuantities(products);
            }

            // Generate the invoice manually and add the selected products
            Invoice generatedInvoice = invoiceService.generateInvoiceManually(customer, null, employeeId, month, productsWithQuantity);
            return ResponseEntity.ok("Invoice generated successfully. Invoice ID: " + generatedInvoice.getInvoiceID());
        } catch (InvoiceGenerationException e) {
            return ResponseEntity.badRequest().body(e.getMessage());
        }
    }
}



InvoiceControllerUtil.java:

package com.crm.wm.controllers;

import com.crm.wm.entities.Product;
import com.crm.wm.services.ProductWithQuantity;

import java.util.ArrayList;
import java.util.List;

public class InvoiceControllerUtil {

    public static List<ProductWithQuantity> mapProductsWithQuantities(List<Product> products, List<Integer> quantities) {
        List<ProductWithQuantity> productsWithQuantity = new ArrayList<>();
        for (int i = 0; i < products.size(); i++) {
            Product product = products.get(i);
            Integer quantity = quantities.get(i);
            productsWithQuantity.add(new ProductWithQuantity(product, quantity));
        }
        return productsWithQuantity;
    }

    public static List<ProductWithQuantity> mapProductsWithQuantities(List<Product> products) {
        List<ProductWithQuantity> productsWithQuantity = new ArrayList<>();
        for (Product product : products) {
            productsWithQuantity.add(new ProductWithQuantity(product, 1));
        }
        return productsWithQuantity;
    }
}


